//parameters as indicated from the charts from lab 1 and tachometer readings
//**ESC VS RPM OF BIG MOTOR EQ IS y=-85.052x + 125700
//**VOLTAGIN(BIGMOTOR) VS. RPM EQ IS y=637.27x-275.86
//**VOLTAGEOUT(SMALLMOTOR) VS. RPM EQ IS y=4935.9x+17.598
//****determine ESC setting for an appropriate rpm than get the voltage out that the tacho/smallmotor would experience
//****use percentage as jamiel suggested for the speed
//****setting max at ~1m/s so 1474 or 1526 (depends on the rotation of the large motor clockwise or counter clockwise)
//****for the esc vs. rpm y=-85.052x + 125700
//****for tachometer voltage, we expect ~0.055962744 volts at 1m/s
//***** for gordons code it bases it in the postive so 1500+ if in the case the motor is 
//***** orientated in the opposite direction, go down and change it to be 1500 - u/V etc...
//truncate to 1

#include <Servo.h>
#include <Arduino.h>
#include <math.h>
#include<avr/io.h>
#include<avr/interrupt.h>
#define BIT(a) (1 << (a))

Servo servo1;
const byte speed_pin=A3;
const byte tacho_pin=A0;
int motorspeed=1500; //intial esc setting for neutral, can be changed through this variable
int startme=0;
volatile float r=0.1; //voltage output from tachometer preset, we actually want ~0.056 for 1m/s
volatile int rpm=1; //desired rpm for the car
volatile int Tacho_vin=0.056; //using just to initialize the variable

void task1();

void setup_ADC();

unsigned long int t0;

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  Serial.print("\nturn on ESC now\n");

  servo1.attach(speed_pin);
  servo1.writeMicroseconds(motorspeed); //This is where you want to set at neutral aka 1500 and than determine the range by percentage from lets say 1500 to 1800. depending on the lab results
  //could run it slowly at 1550 that is for sure.
  //gordon suggest max = 1500 + 300 = 1800 && min = 1500 - 300 = 1200
  
  delay(1000); //wait 10s for ESC to turn on/calibrate

  setup_ADC();

  t0=micros();

  while(1) task1();

  delay(1000);
  exit(0);
}

void task1(){

  int i, n;
  float input_A0, voltage_A0;
  unsigned long int t, t1, dt, k, sum;
  float y, u, kp, e, ed, u_max, u_min; //y is the voltage generated by the tachometer
  //use that for the rpm relation y=4935.9x+17.598 get x to get rpm associated with that voltage
  int u_ESC;
  const float ADC_to_V = 1.0/1023.0*5;
  static float ei = 0.0, ep = 0.0;
  // use small tp value so initial T is large (->intial ed is zero)
  static float tp = -1.0e6;
  float ki, kd, T, rd;

  // battery voltage (V) -- assume constant for now
  const float V_bat = 11.5;
  const float V_bat_inv = 1/V_bat;

  // Testing procedure for control software
  // A) open loop testing -> verify sensors, actuators, units, saturation,
  // input polarity (u and y same direction for steady-state),
  // sample rate (ie dt), noise reduction filter, etc.
  // B) closed loop testing for small kp, u_max -> less chance of instability
  // C) optimize performance by tuning kp, umax, dt, etc.
  
  // step 0) read the clock to measure the time
  // -> needed for plotting and maybe to calculate r(t) 

  t1 = micros()- t0;

  // step 1) read / filter the sensor / output y ///////////

  n=100;
  sum=0;
  for(i=0; i<n; i++){

    ADCSRA |= BIT(ADSC); //ADC start conversion
    //BIT(ADSC) will read as 1 when a conversion is in process
    //and turn to 0 when complete
    //block / wait until ADC conversion is complete

    k=0;
    while(ADCSRA & BIT(ADSC)) k++;

    //read the ADC (10-bits) // 0 - 1023
    sum += ADC;

    // sum += analogRead(A0);
  }

  input_A0 = (float)sum/n; //average analog input
  // note that the simple division of float below takes around 40 
  // us compared to around 4 us for equivalent multiplication
  // which adds a significant time to ADC conversion (112 us vs 152 us).
  // -> avoid using float division if possible
  // -> use multiplication instead of division when possible
  // -> avoid putting float division in loops
  //  voltage_A0 = input_A0 / 1023.0 * 5;
  voltage_A0 = input_A0 * ADC_to_V; //this is much faster than / above

  //current time (us)
  t= micros()- t0;

  // set output y
  //in some cases a change of units / scaling may be required
  //in this case V is good since it has a good physical meaning
  //related to the tach/motor model
  y=voltage_A0; //read output

  //note tach voltage is directly propertional to tach speed
  //-> related to car speed / wheel speed / drive belt speed
  //-> because there is essentially no currentin the tach
  // since the ADC has a very high input resistance (> 100k Ohm)
  // -> the tach is an open circuit

  // length of ADC interval (us)
  dt = t - t1; // for adjusting / optimizing the sensor filter

  // step 2) calculate the control input////

  kp = 5.0; // proportional controller gain, 40% FOS to protect against
  // mainly modelling uncertainty and different motors
  //kp = 7.0; // ultimate limit, kp = 8 oscillates -> unstable / marginal
  kd = 0.0; // P controller
  ki = 100.0; // P controller

  //kd=0.1; // doesn't work due to noise in ed calculations
  //ki=25.0;

   //desired / reference output (V) is r = 0.75 by gordon but do not let his sexual aura control you
  // make sure this is in range of the small motor / tach (0 to 1.2 V)
  rd = 0.0; // step input

  e = r - y; // controller error

  t= 0.014;

  ei += e*T; //integral of the error
  // it's sometimes more consistent to use a constant T
  // based on previous measurements for ei and ed
  // try both for both ei and ed and compare

  T = t*1.0e-6 -tp; // controller period in seconds

  ed = (e-ep)/T; // derivate of error

  //save previous values
  ep = e;
  tp = t*1.0e-6; // time in seconds

  // u = kp*e; // proportional control input Va (-V_bat to V_bat)
  // u = kp*e + kd*ed; // PD controller
  // u = kp*e + ki*ei; // PI controller

  u = kp*e + ki*ei + kd*ed; // PID controller

  // software input saturation //

// u = 2.5; //open loop control -- ie set the input manually / externally

  // use max u_max less than V_bat for safer initial testing
  u_max = 11; // u_max <= V_bat
  u_min = -11; // u_min >= -V_bat

  // software saturation of inputs
  if( u > u_max ) u = u_max;
  if (u < u_min ) u = u_min;

  // step 3) set/command actuators with the control input //////

  // for ESC use neutral of 1500 us and +/- 300 us range ->
  // max = 1500 + 300 = 1800
  // min = 1500 - 300 = 1200    
  
  // convert u to actuator units/scaling the microcontroller / ESC uses
  // (in microseconds) with the formula below
  // note u / V_bat ranges from -1 to 1 or less (depending on umin,umax)
//  u_ESC = 1500 + (u/V_bat)*300;
  
 // u_ESC = 1500 + u*V_bat_inv*300; // faster than division

  u_ESC = 1500 + u*V_bat_inv*100; // use 50 for lower ESC speed
  //can increase after initial testing

  //writeMicroseconds(us) is more precise than write(deg)
  servo1.writeMicroseconds(u_ESC);
  motorspeed = u_ESC;

  // 4) (optional) print out / record testing data //////

  Serial.print("t= ");
  Serial.print(t);
  Serial.print(" ");  

  Serial.print("e= ");
  Serial.print(e);
  Serial.print(" ");

  Serial.print("u= ");
  Serial.print(u);
  Serial.print(" ");

  // Serial.print(ki*ei);
  // Serial.print(" ");

  Serial.print("T= ");
  Serial.print(T, 5);

  Serial.print("\n");

  Serial.print(motorspeed, " ESC setting.\n");

  Serial.print("y (voltage from tach)= ");
  Serial.print(y);
  Tacho_vin=y;
  rpm= (4935.9*(Tacho_vin))+17.598;
  Serial.print("\nrpm of the car = ");
  Serial.print(rpm);
  Serial.print("\n");

  
  
  delay(1);
}

void setup_ADC()
{
  cli();  // disable interrupts
 
  // select current ADC channel A0
  ADMUX = 0; // A0 is default
//  ADMUX |= BIT(MUX0) | BIT(MUX2); // select channel A5
  
    // be careful about changing the channel when a 
  // conversion is in process -- it might take a few
  // extra cycles to get a stable value.
 
  // set ADC reference (max input voltage) to 5V (micrcontroller Vcc) 
  // note: the default (0) takes the reference from the Aref pin
  ADMUX |= BIT(REFS0);
 
  // set ADC control and status register A
  ADCSRA = 0;
  
  ADCSRA |= BIT(ADEN); // ADC enable
    
//  ADCSRA |= BIT(ADIE); // ADC interrupt enable
  // note: uncomment out this line if you want the ADC complete
  // interrupt to function  
  // note: you don't need to use ADC interrupts 
  // you can just set BIT(ADSC) and wait for it to return to 0
  // as is done in the loop() function
  
  // ADPS0, ADPS1, ADPS2 - system clock to ADC input clock prescaler bits
  // smaller prescaler results in faster conversions, but too fast
  // reduces ADC resolution and accuracy
  ADCSRA |= BIT(ADPS0) | BIT(ADPS1) | BIT(ADPS2); // 128 prescaler (slowest)
  // this gives a conversion time of 116 microseconds for one channel
  
//  ADCSRA |= BIT(ADPS1) | BIT(ADPS2); // 64 prescaler
  // this gives a conversion time of 60 microseconds for one channel

//  ADCSRA |= BIT(ADPS0) | BIT(ADPS2); // 32 prescaler  
  
//  ADCSRA |= BIT(ADPS2); 
  // 16 prescaler (smaller than this are very inaccurate)
  
  // note: smaller prescaler values will result in faster conversion times.
  // however, at some point accuracy might be lost -- check a given 
  // prescaler for known input voltages to verify accuracy
  
  sei(); // enable interrupts
}

void loop() {
  // put your main code here, to run repeatedly:

}
